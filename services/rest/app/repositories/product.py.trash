from typing_extensions import Optional
from sqlalchemy.ext.asyncio.session import AsyncSession
from sqlalchemy.orm import selectinload
from sqlalchemy.sql.expression import select
from sqlalchemy import func

from app.models.product import Product


class ProductRepository:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_all_filtered_paginated(
        self,
        title: Optional[str] = None,
        article_number: Optional[str] = None,
        confirmed: Optional[bool] = None,
        id: Optional[int] = None,
        # !!!
        videos: Optional[list[int]] = None,
        page: Optional[int] = None,
        size: Optional[int] = None
    ) -> dict:
        query = select(Product).options(selectinload(Product.videos))

        # Фильтрация
        if id is not None:
            query = query.filter(Product.id == id)
        if article_number is not None:
            query = query.filter(Product.article_number == article_number)
        if confirmed is not None:
            query = query.filter(Product.confirmed == confirmed)
        if title is not None:
            query = query.filter(
                func.lower(
                    Product.title
                ).contains(func.lower(title))
            )

        query = query.order_by(Product.created_at.desc())

        # Пагинация
        if page is not None and size is not None:
            offset = (page - 1) * size
            query = query.offset(offset).limit(size)
            result = await self.db.execute(query)
            products = result.scalars().all()

            # Подсчет общего количества для пагинации
            count_query = select(func.count()).select_from(query.subquery())
            total_result = await self.db.execute(count_query)
            total = total_result.scalar()

            return {
                "products": products,
                "pagination": {
                    "page": page,
                    "size": size,
                    "total": total,
                    "pages": (total + size - 1) // size
                }
            }
        else:
            result = await self.db.execute(query)
            products = result.scalars().all()
            return {"products": products}

    async def get_by_id(self, id: int) -> Optional[Product]:
        query = select(Product).options(selectinload(Product.videos)).filter_by(id=id)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    async def get_by_article_number(self, article_number: str) -> Optional[Product]:
        result = await self.db.execute(select(Product).filter_by(article_number=article_number))
        return result.scalar_one_or_none()

    async def create(self, dto: Product) -> Product:
        product_data = dto.model_dump()
        product = Product(**product_data)

        self.db.add(product)
        await self.db.commit()
        await self.db.refresh(product)
        return product

    async def update(self, id: int, dto: Product) -> Product | None:
        result = await self.db.execute(select(Product).filter_by(id=id))
        product = result.scalar_one_or_none()

        if not product:
            return None

        update_data = dto.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(product, field, value)

        await self.db.commit()
        await self.db.refresh(product)
        return product

    async def delete(self, id: int) -> bool:
        result = await self.db.execute(select(Product).filter_by(id=id))
        product = result.scalar_one_or_none()

        if not product:
            return False

        await self.db.delete(product)
        await self.db.commit()
        return True
